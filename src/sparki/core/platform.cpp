#include "sparki/core/platform.h"

#include <cassert>
#include "imgui/imgui.h"


namespace {

using namespace sparki::core;

// The global is set by sparki::platform's ctor and reset to null by sparki::platform's dctor.
// It is meant to be used only in window_proc.
platform_system* gp_platform = nullptr;


// Returns viewport size of the specified window.
inline uint2 get_viewport_size(HWND p_hwnd)
{
	assert(p_hwnd);

	RECT rect;
	GetClientRect(p_hwnd, &rect);
	return uint2(rect.right - rect.left, rect.bottom - rect.top);
}

mouse_buttons make_mouse_buttons(WPARAM w_param) noexcept
{
	auto buttons = mouse_buttons::none;

	int btn_state = GET_KEYSTATE_WPARAM(w_param);
	if ((btn_state & MK_LBUTTON) == MK_LBUTTON) buttons |= mouse_buttons::left;
	if ((btn_state & MK_MBUTTON) == MK_MBUTTON) buttons |= mouse_buttons::middle;
	if ((btn_state & MK_RBUTTON) == MK_RBUTTON) buttons |= mouse_buttons::right;

	return buttons;
}

inline uint2 point_2d(LPARAM l_param) noexcept
{
	return uint2(LOWORD(l_param), HIWORD(l_param));
}

void process_keyboard_message(key_state s, WPARAM w_param, LPARAM l_param)
{
	constexpr LPARAM extended_key_flag_mask = 1 << 24;
	const bool is_extended_key = (l_param & extended_key_flag_mask) == extended_key_flag_mask;

	key k = key::unknown;
	switch (w_param) {
		case VK_MENU:
			// It can be generated by KEYDOWN and SYSKEYDOWN simultaneously.
			k = (is_extended_key) ? (key::alt_right) : (key::alt_left);
			break;

		case VK_CONTROL:
			k = (is_extended_key) ? (key::ctrl_right) : (key::ctrl_left);
			break;

		case VK_APPS:		k = key::apps; break;
		case VK_BACK:		k = key::backspace; break;
		case VK_CAPITAL:	k = key::caps_lock; break;
		case 0xBC:			k = key::comma; break;
		case VK_DELETE:		k = key::del; break;
		case 0x30:			k = key::digit_0; break;
		case 0x31:			k = key::digit_1; break;
		case 0x32:			k = key::digit_2; break;
		case 0x33:			k = key::digit_3; break;
		case 0x34:			k = key::digit_4; break;
		case 0x35:			k = key::digit_5; break;
		case 0x36:			k = key::digit_6; break;
		case 0x37:			k = key::digit_7; break;
		case 0x38:			k = key::digit_8; break;
		case 0x39:			k = key::digit_9; break;
		case VK_DOWN:		k = key::arrow_down; break;
		case VK_END:		k = key::end; break;
		case VK_RETURN:		k = key::enter; break;
		case VK_ESCAPE:		k = key::escape; break;
		case VK_F1:			k = key::f1; break;
		case VK_F2:			k = key::f2; break;
		case VK_F3:			k = key::f3; break;
		case VK_F4:			k = key::f4; break;
		case VK_F5:			k = key::f5; break;
		case VK_F6:			k = key::f6; break;
		case VK_F7:			k = key::f7; break;
		case VK_F8:			k = key::f8; break;
		case VK_F9:			k = key::f9; break;
		case VK_F10:		k = key::f10; break;
		case VK_F11:		k = key::f11; break;
		case VK_F12:		k = key::f12; break;
		case VK_F13:		k = key::f13; break;
		case VK_F14:		k = key::f14; break;
		case VK_F15:		k = key::f15; break;
		case VK_HOME:		k = key::home; break;
		case VK_INSERT:		k = key::insert; break;
		case VK_LEFT:		k = key::arrow_left; break;
		case 0xBD:			k = key::minus; break;
		case VK_NUMPAD0:	k = key::numpad_0; break;
		case VK_NUMPAD1:	k = key::numpad_1; break;
		case VK_NUMPAD2:	k = key::numpad_2; break;
		case VK_NUMPAD3:	k = key::numpad_3; break;
		case VK_NUMPAD4:	k = key::numpad_4; break;
		case VK_NUMPAD5:	k = key::numpad_5; break;
		case VK_NUMPAD6:	k = key::numpad_6; break;
		case VK_NUMPAD7:	k = key::numpad_7; break;
		case VK_NUMPAD8:	k = key::numpad_8; break;
		case VK_NUMPAD9:	k = key::numpad_9; break;
		case VK_DECIMAL:	k = key::numpad_comma; break;
		case VK_DIVIDE:		k = key::numpad_devide; break;
		case VK_NUMLOCK:	k = key::num_lock; break;
		case VK_SUBTRACT:	k = key::numpad_minus; break;
		case VK_MULTIPLY:	k = key::numpad_multiply; break;
		case VK_ADD:		k = key::numpad_plus; break;
		case VK_NEXT:		k = key::page_down; break;
		case VK_PRIOR:		k = key::page_up; break;
		case VK_PAUSE:		k = key::pause; break;
		case 0xBE:			k = key::period; break;
		case 0xBB:			k = key::plus; break;
		case VK_SNAPSHOT:	k = key::prtsrc; break;
		case 0xDE:			k = key::quote; break;
		case 0xC0:			k = key::quote_back; break;
		case VK_RIGHT:		k = key::arrow_right; break;
		case VK_SCROLL:		k = key::scroll_lock; break;
		case 0xBA:			k = key::semicolon; break;
		case VK_SHIFT:		k = key::shift_left; break; // BUG: When Right Shift is pressed isExtendedKey equals 0 instead of 1
		case 0xDC:			k = key::slash; break;
		case 0xBF:			k = key::slash_back; break;
		case VK_SPACE:		k = key::space; break;
		case 0xDD:			k = key::square_bracket_close; break;
		case 0xDB:			k = key::square_bracket_open; break;
		case VK_TAB:		k = key::tab; break;
		case VK_UP:			k = key::arrow_up; break;
		case VK_LWIN:		k = key::win_left; break;
		case VK_RWIN:		k = key::win_right; break; // TEST IT:
		case 0x41:			k = key::a; break;
		case 0x42:			k = key::b; break;
		case 0x43:			k = key::c; break;
		case 0x44:			k = key::d; break;
		case 0x45:			k = key::e; break;
		case 0x46:			k = key::f; break;
		case 0x47:			k = key::g; break;
		case 0x48:			k = key::h; break;
		case 0x49:			k = key::i; break;
		case 0x4A:			k = key::j; break;
		case 0x4B:			k = key::k; break;
		case 0x4C:			k = key::l; break;
		case 0x4D:			k = key::m; break;
		case 0x4E:			k = key::n; break;
		case 0x4F:			k = key::o; break;
		case 0x50:			k = key::p; break;
		case 0x51:			k = key::q; break;
		case 0x52:			k = key::r; break;
		case 0x53:			k = key::s; break;
		case 0x54:			k = key::t; break;
		case 0x55:			k = key::u; break;
		case 0x56:			k = key::v; break;
		case 0x57:			k = key::w; break;
		case 0x58:			k = key::x; break;
		case 0x59:			k = key::y; break;
		case 0x5A:			k = key::z; break;
	}

	if (k != key::unknown)
		gp_platform->enqueue_keypress(k, s);
}

inline void process_mouse_button_message()
{

}

// Retrieves and dispatches all the system messages that are in the message queue at the moment.
// Returns true if the application has to terminate.
bool pump_sys_messages() noexcept
{
	MSG msg;
	while (PeekMessage(&msg, nullptr, 0, 0, PM_REMOVE)) {
		if (msg.message == WM_QUIT) return true;

		TranslateMessage(&msg);
		DispatchMessageA(&msg);
	}

	return false;
}

// Refreshes mouse state.
// Keyboard has not been implemented.
void refresh_input_state(input_state& s, HWND p_hwnd, const uint2& wnd_client_size)
{
	assert(p_hwnd);
	assert(wnd_client_size > 0);

	auto mb = mouse_buttons::none;
	if (HIWORD(GetKeyState(VK_LBUTTON)) == 1) mb |= mouse_buttons::left;
	if (HIWORD(GetKeyState(VK_MBUTTON)) == 1) mb |= mouse_buttons::middle;
	if (HIWORD(GetKeyState(VK_RBUTTON)) == 1) mb |= mouse_buttons::right;

	// mouse position & is_out
	POINT cp;
	GetCursorPos(&cp);
	ScreenToClient(p_hwnd, &cp);

	const bool is_out = (cp.x < 0) || (static_cast<uint32_t>(cp.x) >= wnd_client_size.x)
		|| (cp.y < 0) || (static_cast<uint32_t>(cp.y) >= wnd_client_size.y);

	s.mouse_is_out = is_out;

	if (!is_out)
		s.mouse_position = uint2(cp.x, wnd_client_size.y - cp.y - 1);
}

inline void show_window(HWND p_hwnd) noexcept
{
	assert(p_hwnd);

	ShowWindow(p_hwnd, SW_SHOW);
	SetForegroundWindow(p_hwnd);
	SetFocus(p_hwnd);
}

// ditto
inline void refresh_input_state(input_state& s, HWND p_hwnd)
{
	refresh_input_state(s, p_hwnd, get_viewport_size(p_hwnd));
}

LRESULT CALLBACK window_proc(HWND p_hwnd, UINT message, WPARAM w_param, LPARAM l_param)
{
	if (!gp_platform)
		return DefWindowProc(p_hwnd, message, w_param, l_param);

	ImGuiIO& io = ImGui::GetIO();
	assert(p_hwnd == gp_platform->p_hwnd());

	switch (message) {
		default:
			return DefWindowProc(p_hwnd, message, w_param, l_param);

// ----- keyboard -----
		case WM_KEYDOWN:
		{
			process_keyboard_message(key_state::down, w_param, l_param);
			return 0;
		}

		case WM_KEYUP:
		{
			process_keyboard_message(key_state::released, w_param, l_param);
			return 0;
		}

// ----- mouse -----

		case WM_LBUTTONDOWN: 
		{
			assert(!gp_platform->input_state().mouse_is_out);
			io.MouseDown[0] = true;
			gp_platform->enqueue_mouse_button(make_mouse_buttons(w_param));
			return 0;
		}

		case WM_LBUTTONUP:
		{
			assert(!gp_platform->input_state().mouse_is_out);
			io.MouseDown[0] = false;
			gp_platform->enqueue_mouse_button(make_mouse_buttons(w_param));
			return 0;
		}

		case WM_MBUTTONDOWN:
		{
			assert(!gp_platform->input_state().mouse_is_out);
			io.MouseDown[1] = true;
			gp_platform->enqueue_mouse_button(make_mouse_buttons(w_param));
			return 0;
		}

		case WM_MBUTTONUP:
		{
			assert(!gp_platform->input_state().mouse_is_out);
			io.MouseDown[1] = false;
			gp_platform->enqueue_mouse_button(make_mouse_buttons(w_param));
			return 0;
		}

		case WM_RBUTTONDOWN:
		{
			assert(!gp_platform->input_state().mouse_is_out);
			io.MouseDown[2] = true;
			gp_platform->enqueue_mouse_button(make_mouse_buttons(w_param));
			return 0;
		}

		case WM_RBUTTONUP:
		{
			assert(!gp_platform->input_state().mouse_is_out);
			io.MouseDown[2] = false;
			gp_platform->enqueue_mouse_button(make_mouse_buttons(w_param));
			return 0;
		}

		case WM_MOUSEMOVE:
		{
			if (p_hwnd != GetFocus())
				return DefWindowProc(p_hwnd, message, w_param, l_param);

			// p0 is relative to the top-left window corner
			// p is relative to the bottom-left window corner
			const uint2 p0 = point_2d(l_param);
			io.MousePos.x = float(p0.x);
			io.MousePos.y = float(p0.y);


			const uint2 vp = get_viewport_size(p_hwnd);
			const uint2 p(p0.x, vp.y - p0.y - 1);

			if (gp_platform->input_state().mouse_is_out)
				gp_platform->enqueue_mouse_enter(make_mouse_buttons(w_param), p);
			else 
				gp_platform->enqueue_mouse_move(p);

			TRACKMOUSEEVENT tme { sizeof(TRACKMOUSEEVENT), TME_LEAVE, p_hwnd, 0 };
			TrackMouseEvent(&tme);
			return 0;
		}

		case WM_MOUSELEAVE:
		{
			gp_platform->enqueue_mouse_leave();
			return 0;
		}

		case WM_MOUSEWHEEL:
		{
			io.MouseWheel += (GET_WHEEL_DELTA_WPARAM(w_param) > 0) ? 1.0f : -1.0f;
			return 0;
		}
		
		case WM_DESTROY:
		{
			PostQuitMessage(0);
			return 0;
		}

		case WM_SIZE:
		{
			gp_platform->enqueue_window_resize();
			return 0;
		}
	}
}

} // namespace


namespace sparki {
namespace core {

// ----- platform  -----

platform_system::platform_system(const window_desc& window_desc)
{
	assert(is_valid_window_desc(window_desc));
	sys_messages_.reserve(256);
	init_window(window_desc);

	gp_platform = this;
}

platform_system::~platform_system() noexcept
{
	gp_platform = nullptr;

	if (IsWindow(p_hwnd_))
		DestroyWindow(p_hwnd_);
	p_hwnd_ = nullptr;

	// window class
	UnregisterClass(platform_system::window_class_name, GetModuleHandle(nullptr));
}

void platform_system::before_main_loop()
{
	show_window(p_hwnd_);
	refresh_input_state(input_state_, p_hwnd_);
}

void platform_system::init_window(const window_desc& desc)
{
	HINSTANCE p_hinstance = GetModuleHandle(nullptr);
	assert(!desc.fullscreen); // NOTE(ref2401): Not implemented

	// register the window's class
	WNDCLASSEX wnd_class = {};
	wnd_class.cbSize = sizeof(wnd_class);
	wnd_class.style = CS_OWNDC | CS_HREDRAW | CS_VREDRAW;
	wnd_class.lpfnWndProc = window_proc;
	wnd_class.cbClsExtra = 0;
	wnd_class.cbWndExtra = 0;
	wnd_class.hInstance = p_hinstance;
	wnd_class.hIcon = nullptr;
	wnd_class.hCursor = LoadCursor(nullptr, IDI_APPLICATION);
	wnd_class.hbrBackground = nullptr;
	wnd_class.lpszMenuName = nullptr;
	wnd_class.lpszClassName = platform_system::window_class_name;

	ATOM reg_res = RegisterClassEx(&wnd_class);
	assert(reg_res != 0);

	// create a window
	RECT wnd_rect;
	wnd_rect.left = desc.position.x;
	wnd_rect.top = desc.position.y;
	wnd_rect.right = desc.position.x + desc.viewport_size.x;
	wnd_rect.bottom = desc.position.y + desc.viewport_size.y;
	AdjustWindowRectEx(&wnd_rect, WS_OVERLAPPEDWINDOW, false, WS_EX_APPWINDOW);

	p_hwnd_ = CreateWindowEx(WS_EX_APPWINDOW, platform_system::window_class_name, desc.title.c_str(),
		WS_OVERLAPPEDWINDOW | WS_CLIPSIBLINGS | WS_CLIPCHILDREN,
		wnd_rect.left, wnd_rect.top, wnd_rect.right - wnd_rect.left, wnd_rect.bottom - wnd_rect.top,
		nullptr, nullptr, p_hinstance, nullptr);
	assert(p_hwnd_);
}

bool platform_system::process_sys_messages(event_listener_i& listener)
{
	if (pump_sys_messages()) return true; // NOTE(ref2401): true - app has to terminate.
	if (sys_messages_.empty()) return false;

	for (const auto& msg : sys_messages_) {
		switch (msg.type) {
			default:
			{
				assert(false);
				break;
			}

			case sys_message::type::keypress:
			{
				set_key_state(input_state_, msg.key, msg.key_state);
				listener.on_keypress(msg.key, msg.key_state);
				break;
			}

			case sys_message::type::mouse_button:
			{
				input_state_.mouse_buttons = msg.mouse_buttons;
				listener.on_mouse_click();
				break;
			}

			case sys_message::type::mouse_enter:
			{
				input_state_.mouse_is_out = false;
				input_state_.mouse_buttons = msg.mouse_buttons;
				input_state_.mouse_position = msg.uint2;
				break;
			}

			case sys_message::type::mouse_leave:
			{
				input_state_.mouse_is_out = true;
				break;
			}

			case sys_message::type::mouse_move:
			{
				input_state_.mouse_position = msg.uint2;
				listener.on_mouse_move();
				break;
			}

			case sys_message::type::viewport_resize:
			{
				listener.on_resize_viewport(msg.uint2);
				break;
			}
		}
	}

	sys_messages_.clear();
	return false;
}

void platform_system::enqueue_keypress(key k, key_state s)
{
	assert(k != key::unknown);

	sys_message msg;
	msg.type = sys_message::type::keypress;
	msg.key = k;
	msg.key_state = s;
	sys_messages_.push_back(msg);
}

void platform_system::enqueue_mouse_button(mouse_buttons mb)
{
	sys_message msg;
	msg.type = sys_message::type::mouse_button;
	msg.mouse_buttons = mb;
	sys_messages_.push_back(msg);
}

void platform_system::enqueue_mouse_enter(mouse_buttons mb, const uint2& p)
{
	sys_message msg;
	msg.type = sys_message::type::mouse_enter;
	msg.mouse_buttons = mb;
	msg.uint2 = p;
	sys_messages_.push_back(msg);
}

void platform_system::enqueue_mouse_leave()
{
	sys_message msg;
	msg.type = sys_message::type::mouse_leave;
	sys_messages_.push_back(msg);
}

void platform_system::enqueue_mouse_move(const uint2& p)
{
	sys_message msg;
	msg.type = sys_message::type::mouse_move;
	msg.uint2 = p;
	sys_messages_.push_back(msg);
}

void platform_system::enqueue_window_resize()
{
	sys_message msg;
	msg.type = sys_message::type::viewport_resize;
	msg.uint2 = get_viewport_size(p_hwnd_);
	sys_messages_.push_back(msg);
}

// ----- funcs -----

bool is_valid_window_desc(const window_desc& desc) noexcept
{
	return (desc.title.length() > 0)
		&& (desc.viewport_size > 0);
}

} // namespace core
} // namespace sparki
